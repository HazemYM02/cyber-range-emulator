#!/usr/bin/env python3
import os, json, socket, random, subprocess, datetime, urllib.parse
from pathlib import Path

# ----------------------------
# CONFIG
# ----------------------------
TARGETS = [
    "10.88.30.10",  # Victim node
    "10.88.20.10",  # IoT device 1
    "10.88.20.12",  # IoT device 2
    "10.88.20.13",  # IoT device 3
    "10.88.20.14",  # IoT device 4
]
OUTPUT_DIR = Path("./wapiti_scan_results")
WAPITI_BIN = "wapiti"              # or "wapiti3" depending on your install
FORMAT = "json"                    # json for parsing; an html is also saved for review
HTML_REPORTS_TOO = True            # also write a pretty HTML report
SCAN_MODULES = "xss,sql,backup,file,redirect,crlf,ssrf"  # enable common web vulns
TIMEOUT_S = 20

# Optional: send lifecycle events to Splunk raw TCP input (set to None to disable)
SPLUNK_IP = "10.88.10.200"
SPLUNK_PORT = 9997
SPLUNK_SOURCETYPE = "auto_attack"

# ----------------------------
# helpers
# ----------------------------
def now_iso():
    return datetime.datetime.utcnow().isoformat() + "Z"

def splunk_emit(event: dict):
    if not SPLUNK_IP or not SPLUNK_PORT:
        return
    try:
        with socket.create_connection((SPLUNK_IP, SPLUNK_PORT), timeout=2) as s:
            event.setdefault("ts", now_iso())
            event.setdefault("source", "auto")
            s.sendall((json.dumps(event) + "\n").encode())
    except Exception:
        pass  # stay quiet if Splunk is unreachable

def run(cmd: list, **popen_kwargs):
    return subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, **popen_kwargs)

def ensure_requests():
    try:
        import requests  # noqa: F401
        return True
    except Exception:
        return False

# ----------------------------
# wapiti scanning
# ----------------------------
def run_wapiti_scan_json(target: str) -> dict:
    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
    base = f"wapiti_scan_{target.replace('.', '_')}"
    json_path = OUTPUT_DIR / f"{base}.json"
    html_path = OUTPUT_DIR / f"{base}.html"

    url = f"http://{target}/"
    splunk_emit({"stage": "attack_started", "tool": "wapiti", "target": target})

    args = [
        WAPITI_BIN, "-u", url,
        "-m", SCAN_MODULES,
        "-f", FORMAT, "-o", str(json_path),
        "--color", "never",
    ]
    # optional HTML report for humans
    if HTML_REPORTS_TOO:
        args_html = [
            WAPITI_BIN, "-u", url,
            "-m", SCAN_MODULES,
            "-f", "html", "-o", str(html_path),
            "--color", "never",
        ]
        run(args_html, timeout=600)

    res = run(args, timeout=600)
    if res.returncode not in (0, 1):  # wapiti returns 1 if vulns found in some versions
        splunk_emit({"stage": "scan_error", "tool": "wapiti", "target": target,
                     "stderr": res.stderr[-400:]})
        raise RuntimeError(f"Wapiti failed: {res.stderr.strip()}")

    data = {}
    if json_path.exists():
        try:
            data = json.loads(json_path.read_text(errors="ignore") or "{}")
        except json.JSONDecodeError:
            pass

    return {"json_path": str(json_path), "html_path": str(html_path), "data": data}

# ----------------------------
# very light exploit attempts (verification pings)
# ----------------------------
def try_requests():
    import requests
    requests.packages.urllib3.disable_warnings()  # ignore self-signed
    return requests

def attempt_verify(target: str, findings: list) -> list:
    """
    Try minimal, non-destructive requests to verify common classes:
      - XSS: reflect a benign marker
      - SQLi: append a quote and look for SQL error patterns
      - File include: try /etc/hosts traversal
    Returns a list of dicts describing attempts and outcomes.
    """
    attempts = []
    if not ensure_requests() or not findings:
        return attempts

    requests = try_requests()
    markers = {
        "xss": "<xss_probe_123>",
        "sql": "'\"")  # noqa: E231
    }
    sql_error_patterns = ("SQL syntax", "mysql", "sqlite", "ORA-", "ODBC", "psql", "PostgreSQL", "Warning: mysqli")

    for f in findings:
        atype = f.get("name") or f.get("anomaly") or f.get("module") or ""
        vect = f.get("vinfo") or f.get("info") or {}
        url = vect.get("url") or f.get("url")
        param = vect.get("parameter") or vect.get("param")
        if not url:
            continue

        try:
            if "xss" in atype.lower():
                # reflect benign marker
                probe = markers["xss"]
                test_url = add_param(url, param or "q", probe)
                r = requests.get(test_url, timeout=TIMEOUT_S, verify=False)
                hit = (probe in r.text)
                attempts.append({"type": "xss", "url": test_url, "status": r.status_code, "verified": hit})
                if hit:
                    splunk_emit({"stage": "attack_succeeded", "tool": "wapiti", "target": target,
                                 "vector": "xss", "evidence": "marker_reflected", "url": test_url})

            elif "sql" in atype.lower():
                probe = markers["sql"]
                test_url = add_param(url, param or "id", probe)
                r = requests.get(test_url, timeout=TIMEOUT_S, verify=False)
                hit = any(pat.lower() in r.text.lower() for pat in sql_error_patterns)
                attempts.append({"type": "sqli", "url": test_url, "status": r.status_code, "verified": hit})
                if hit:
                    splunk_emit({"stage": "attack_succeeded", "tool": "wapiti", "target": target,
                                 "vector": "sqli", "evidence": "error_pattern", "url": test_url})

            elif any(k in atype.lower() for k in ("file", "traversal", "lfi")):
                candidate = "../../../../../../etc/hosts"
                test_url = add_param(url, param or "file", candidate)
                r = requests.get(test_url, timeout=TIMEOUT_S, verify=False)
                hit = "localhost" in r.text and "127.0.0.1" in r.text
                attempts.append({"type": "lfi", "url": test_url, "status": r.status_code, "verified": hit})
                if hit:
                    splunk_emit({"stage": "attack_succeeded", "tool": "wapiti", "target": target,
                                 "vector": "lfi", "evidence": "/etc/hosts", "url": test_url})
        except Exception as e:
            attempts.append({"type": atype or "unknown", "url": url, "error": str(e)})

    return attempts

def add_param(url: str, key: str, val: str) -> str:
    # safely add/replace ?key=val in URL
    parsed = urllib.parse.urlsplit(url)
    q = urllib.parse.parse_qs(parsed.query, keep_blank_values=True)
    q[key] = [val]
    new_q = urllib.parse.urlencode(q, doseq=True)
    return urllib.parse.urlunsplit((parsed.scheme or "http", parsed.netloc, parsed.path or "/", new_q, parsed.fragment))

def flatten_findings(wapiti_data: dict) -> list:
    """
    Wapiti JSON format contains e.g. {"vulnerabilities": [{"name": "...", "vinfo": {"url": "...", "parameter": "..."}, ...}, ...]}
    We normalize what we can; if schema differs, we still return a best-effort list.
    """
    out = []
    if not wapiti_data:
        return out
    vulns = wapiti_data.get("vulnerabilities") or wapiti_data.get("anomalies") or []
    for v in vulns:
        out.append(v)
    return out

# ----------------------------
# main
# ----------------------------
def main():
    target = random.choice(TARGETS)
    splunk_emit({"stage": "target_selected", "tool": "wapiti", "target": target})

    try:
        res = run_wapiti_scan_json(target)
    except Exception as e:
        print(f"[-] Wapiti error: {e}")
        splunk_emit({"stage": "attack_failed", "tool": "wapiti", "target": target, "reason": "scan_error"})
        return

    data = res.get("data") or {}
    findings = flatten_findings(data)
    print(f"[+] Target: {target}")
    print(f"[+] JSON:   {res.get('json_path')}")
    if res.get("html_path"):
        print(f"[+] HTML:   {res.get('html_path')}")
    print(f"[+] Findings (raw count): {len(findings)}")

    # attempt light verification/exploit
    attempts = attempt_verify(target, findings)
    verified = [a for a in attempts if a.get("verified")]
    print(f"[+] Attempted verifications: {len(attempts)} | Verified: {len(verified)}")

    if verified:
        splunk_emit({"stage": "attack_succeeded", "tool": "wapiti", "target": target,
                     "verified_count": len(verified)})
    else:
        splunk_emit({"stage": "attack_ended", "tool": "wapiti", "target": target, "verified_count": 0})

    # optional: print a brief table
    if attempts:
        print("\n[+] Attempt summary:")
        for a in attempts:
            print("   -", a)

if __name__ == "__main__":
    main()